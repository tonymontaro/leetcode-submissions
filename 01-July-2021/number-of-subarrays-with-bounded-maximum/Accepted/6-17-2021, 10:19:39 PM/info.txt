{"id":509425247,"lang":"cpp","time":"1 week, 6 days","timestamp":1623964779,"status_display":"Accepted","runtime":"60 ms","url":"/submissions/detail/509425247/","is_pending":"Not Pending","title":"Number of Subarrays with Bounded Maximum","memory":"35.1 MB","code":"#define pi pair<int, int>\n\nclass Solution {\npublic:\n    int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {\n        int ans = 0, n = nums.size(), remove = 0;\n        vector<pi> seen;\n        vector<int> l(n);\n        vector<int> r(n);\n        for (int i = 0; i < nums.size(); i++) {\n            int idx = i;\n            while (!seen.empty() && nums[i] >= seen.back().first) {\n                idx = seen.back().second;\n                seen.pop_back();\n            }\n            l[i] = idx;\n            seen.emplace_back(nums[i], idx);\n        }\n        seen.clear();\n        for (int i = n - 1; i >= 0; --i) {\n            int idx = i;\n            bool isvalid = left <= nums[i] && nums[i] <= right;\n            int le = i - l[i] + 1;\n            while (!seen.empty() && nums[i] >= nums[seen.back().first]) {\n                int j = seen.back().first;\n                if (isvalid && nums[i] == nums[j]) remove += le * (r[j] - j + 1);\n                idx = seen.back().second;\n                seen.pop_back();\n            }\n            r[i] = idx;\n            if (isvalid) ans += (idx - i + 1) * le;\n            seen.emplace_back(i, idx);\n        }\n        return ans - remove;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111","title_slug":"number-of-subarrays-with-bounded-maximum"}