{"id":409366217,"lang":"python3","time":"8 months, 2 weeks","timestamp":1602831758,"status_display":"Accepted","runtime":"1876 ms","url":"/submissions/detail/409366217/","is_pending":"Not Pending","title":"The Most Similar Path in a Graph","memory":"16.2 MB","code":"from math import inf\n\nclass Solution:\n    def mostSimilar(self, n: int, roads: List[List[int]], names: List[str], target: List[str]) -> List[int]:\n        # O(n^2 * k) time | O(k * n) space | k -> length target\n        adj = [[] for _ in range(n)]\n        for a, b in roads:\n            adj[a].append(b)\n            adj[b].append(a)\n\n        targetLen = len(target)\n        last = target[-1]\n        dp = [[(0, [idx]) if last == name else (1, [idx])] for (idx, name) in enumerate(names)]\n\n        for i in range(1, targetLen):\n            tIdx = targetLen - i - 1\n            for (idx, node) in enumerate(names):\n                cost = 0 if target[tIdx] == node else 1\n                best = inf\n                bestChild = 0\n                for child in adj[idx]:\n                    if dp[child][i - 1][0] < best:\n                        best = dp[child][i - 1][0]\n                        bestChild = child\n                childCost, path = dp[bestChild][i - 1]\n                dp[idx].append((cost + childCost, [idx] + path))\n        return min(dp, key=lambda x: x[-1][0])[-1][1]\n                \n        \n        ","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"the-most-similar-path-in-a-graph"}