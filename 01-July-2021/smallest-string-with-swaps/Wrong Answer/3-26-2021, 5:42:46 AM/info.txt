{"id":472549654,"lang":"cpp","time":"3 months, 1 week","timestamp":1616733766,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/472549654/","is_pending":"Not Pending","title":"Smallest String With Swaps","memory":"N/A","code":"class UnionFind {\n    /*\n    UnionFind or DisjoinSet data-structure with Path compression. Zero indexed.\n    Initialize:\n            UnionFind(n)\n            Methods:\n    unify(p, q)        # unify p and q\n    connected(p, q)    # is p connected to q (return bool)\n    find(p)            # find the parent of q\n    getSize(p)         # return the group size of p\n    */\nprivate:\n    int size = 0;\n    int* sizes;\n    int* parents;\npublic:\n    int groups;\n    UnionFind(int n) {\n        size = n;\n        groups = n;\n        sizes = new int[size];\n        parents = new int[size];\n        for(int i=0; i < size; i++) {\n            parents[i] = i;\n            sizes[i] = 1;\n        }\n    }\n    ~UnionFind() {\n        delete [] sizes;\n        delete [] parents;\n    }\n\n    int find(int p) {\n        assert(p >= 0 && p < size);\n        int root = p;\n        while (root != parents[root])\n            root = parents[root];\n\n        // path compression\n        while (p != root) {\n            int tmp = parents[p];\n            parents[p] = root;\n            p = tmp;\n        }\n        return root;\n    }\n    int getSize(int p) {\n        return sizes[find(p)];\n    }\n\n    bool connected(int p, int q){\n        return find(p) == find(q);\n    }\n    bool unify(int p, int q) {\n        assert(p >= 0 && p < size);\n        assert(q >= 0 && q < size);\n        int root1 = find(p);\n        int root2 = find(q);\n        if (root1 == root2) return false;\n        if (sizes[root1] < sizes[root2]){\n            parents[root1] = root2;\n            sizes[root2] += sizes[root1];\n        } else {\n            parents[root2] = root1;\n            sizes[root1] += sizes[root2];\n        }\n        groups -= 1;\n        return true;\n    }\n    vector<vector<int>> getChildren() {\n        vector<vector<int>> rs(size);\n        for (int i = 0; i < size; i++) {\n            rs[find(i)].push_back(i);\n        }\n        return rs;\n    }\n    void print_sets() {\n        for(int i=0; i < size; i++) cout << find(i) << \" \";\n        cout << endl;\n    }\n};\n\n\n#define ll long long\n#define umap unordered_map\n#define uset unordered_set\n#define pii pair<int, pair<int, int>>\n#define v vector\n\n\nclass Solution {\npublic:\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\n        UnionFind uf = UnionFind(s.size());\n        for (auto x: pairs) {\n            uf.unify(x[0], x[1]);\n        }\n        v<v<int>> children = uf.getChildren();\n        for (auto x: children) {\n            if (x.size() <= 1) continue;\n            set<char> items;\n            for (auto y: x) items.insert(s[y]);\n            sort(x.begin(), x.end());\n            int idx = 0;\n            for (auto y: items) {\n                s[x[idx++]] = y;\n            }\n        }\n        return s;\n    }\n};","compare_result":"111111000000010000000000000000000000","title_slug":"smallest-string-with-swaps"}