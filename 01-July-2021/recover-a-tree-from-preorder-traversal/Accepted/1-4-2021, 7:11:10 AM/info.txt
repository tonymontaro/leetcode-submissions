{"id":438321880,"lang":"python3","time":"5 months, 4 weeks","timestamp":1609740670,"status_display":"Accepted","runtime":"84 ms","url":"/submissions/detail/438321880/","is_pending":"Not Pending","title":"Recover a Tree From Preorder Traversal","memory":"15.1 MB","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, s: str) -> TreeNode:\n        # O(n) time and space\n        nodes = []\n        idx = 0\n        depth = 0\n        while idx < len(s):\n            j = idx\n            while j < len(s) and s[j].isdigit():\n                j += 1\n            node = TreeNode(int(s[idx:j]))\n            idx = j\n            while depth < len(nodes):\n                nodes.pop()\n            if nodes and nodes[-1].left is None:\n                nodes[-1].left = node\n            elif nodes:\n                nodes[-1].right = node\n            nodes.append(node)\n            depth = 0\n            while idx < len(s) and s[idx] == '-':\n                depth += 1\n                idx += 1\n        return nodes[0]\n            ","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"recover-a-tree-from-preorder-traversal"}