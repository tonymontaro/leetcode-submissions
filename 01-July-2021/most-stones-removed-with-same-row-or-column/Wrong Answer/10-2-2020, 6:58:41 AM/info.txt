{"id":403406585,"lang":"java","time":"9Â months","timestamp":1601618321,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/403406585/","is_pending":"Not Pending","title":"Most Stones Removed with Same Row or Column","memory":"N/A","code":"class Solution {\n    public int removeStones(int[][] stones) {\n        HashMap<Integer, List<Tuple>> xs = new HashMap<>();\n        HashMap<Integer, List<Tuple>> ys = new HashMap<>();\n        for (int[] s : stones) {\n            Tuple stone = new Tuple(1, s[0], s[1]);\n            if (xs.containsKey(s[0])) {\n                for (Tuple node: xs.get(s[0])) node.addColMate(stone);\n            } else xs.put(s[0], new ArrayList<>());\n            if (ys.containsKey(s[1])) {\n                for (Tuple node: ys.get(s[1])) node.addRowMate(stone);\n            } else ys.put(s[1], new ArrayList<>());\n            xs.get(s[0]).add(stone);\n            ys.get(s[1]).add(stone);\n        }\n        TreeSet<Tuple> set = new TreeSet<>();\n        for (int k: xs.keySet()) set.addAll(xs.get(k));\n//        out.println(set);\n        int ans = 0;\n        while (!set.isEmpty()) {\n            Tuple first = set.pollFirst();\n            if (first.a < 2) continue;\n            ans++;\n            for (Tuple node : xs.get(first.b)) {\n                set.remove(node);\n                node.a--;\n                node.cols--;\n                if (node.a >= 2) set.add(node);\n            }\n            for (Tuple node : ys.get(first.c)) {\n                set.remove(node);\n                node.a--;\n                node.rows--;\n                if (node.a >= 2) set.add(node);\n            }\n        }\n\n        return ans;\n    }\n\n    static class Tuple implements Comparable<Tuple> {\n        int a;\n        int b;\n        int c;\n        List<Tuple> rowMates = new ArrayList<>();\n        List<Tuple> colMates = new ArrayList<>();\n        int cols = 1;\n        int rows = 1;\n\n        public Tuple(int a, int b) {\n            this.a = a;\n            this.b = b;\n            this.c = 0;\n        }\n        public Tuple(int connected, int x, int y) {\n            this.a = connected;\n            this.b = x;\n            this.c = y;\n        }\n\n        public void addRowMate(Tuple other) {\n            rowMates.add(other);\n            other.rowMates.add(this);\n            this.a++;\n            rows++;\n            other.a++;\n        }\n\n        public void addColMate(Tuple other) {\n            colMates.add(other);\n            other.colMates.add(this);\n            this.a++;\n            cols++;\n            other.a++;\n        }\n        public int getA() { return a; }\n        public int getB() { return b; }\n        public int getC() { return c; }\n        public int compareTo(Tuple other) {\n            if (this.a == other.a) {\n                int ab = abs(this.cols - this.rows);\n                int ao = abs(other.rows - other.cols);\n                if (ab != ao) return Integer.compare(ao, ab);\n                if (this.b == other.b) return Long.compare(this.c, other.c);\n                return Long.compare(this.b, other.b);\n            }\n            return Long.compare(this.a, other.a);\n        }\n        @Override\n        public int hashCode() { return Arrays.deepHashCode(new Integer[]{a, b, c}); }\n        @Override\n        public boolean equals(Object o) {\n            if (!(o instanceof Tuple)) return false;\n            Tuple pairo = (Tuple) o;\n            return (this.a == pairo.a && this.b == pairo.b && this.c == pairo.c);\n        }\n        @Override\n        public String toString() { return String.format(\"(%d %d %d)  \", this.a, this.b, this.c); }\n    }\n    private static int abs(int a){  return (a>=0) ? a: -a;  }\n}","compare_result":"11111111111111111111111111010001000100000000000000000000111111111111","title_slug":"most-stones-removed-with-same-row-or-column"}