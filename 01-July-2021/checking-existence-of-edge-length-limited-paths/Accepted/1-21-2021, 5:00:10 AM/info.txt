{"id":445739956,"lang":"python3","time":"5 months, 1 week","timestamp":1611201610,"status_display":"Accepted","runtime":"2188 ms","url":"/submissions/detail/445739956/","is_pending":"Not Pending","title":"Checking Existence of Edge Length Limited Paths","memory":"61.3 MB","code":"from heapq import heappush, heappop\n\nclass Solution:\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\n        edgeList.sort(key=lambda x: x[2])\n        queries = [[a, b, dist, i] for i, (a, b, dist) in enumerate(queries)]\n        queries.sort(key=lambda x: x[2])\n        \n        res = [False] * len(queries)\n        disjoint = UnionFind(n)\n        idx = 0\n        for a, b, limit, i in queries:\n            while idx < len(edgeList) and edgeList[idx][2] < limit:\n                x, y, dist = edgeList[idx]\n                disjoint.unify(x, y)\n                idx += 1\n            res[i] = disjoint.connected(a, b)\n        return res\n                \n            \n    \n    \nclass UnionFind:\n    \"\"\"\n    UnionFind or DisjoinSet data-structure with Path compression. Zero indexed.\n    Initialize:\n        UnionFind(n)\n    Methods:\n        unify(p, q)        # unify p and q\n        connected(p, q)    # is p connected to q (return bool)\n        find(p)            # find the parent of q\n        getSize(p)         # return the group size of p\n    \"\"\"\n    def __init__(self, n):\n        self.size = n\n        self.groups = n\n        self.sizes = [0] * n\n        self.parents = [0] * n\n        \n        for i in range(n):\n            self.parents[i] = i\n            self.sizes[i] = 1\n    def find(self, p):\n        root = p\n        while (root != self.parents[root]):\n            root = self.parents[root]\n        # path compression\n        while (p != root):\n            p, self.parents[p] = self.parents[p], root\n        return root\n    def getSize(self, p):\n        return self.sizes[self.find(p)]\n    def connected(self, p, q):\n        return self.find(p) == self.find(q)\n    def unify(self, p, q):\n        root1 = self.find(p)\n        root2 = self.find(q)\n        if root1 == root2:\n            return\n        if self.sizes[root1] < self.sizes[root2]:\n            self.parents[root1] = root2\n            self.sizes[root2] += self.sizes[root1]\n        else:\n            self.parents[root2] = root1\n            self.sizes[root1] += self.sizes[root2]\n        self.groups -= 1","compare_result":"11111111111111111111111","title_slug":"checking-existence-of-edge-length-limited-paths"}