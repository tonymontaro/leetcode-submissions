{"id":416856768,"lang":"python3","time":"7 months, 4 weeks","timestamp":1604530572,"status_display":"Accepted","runtime":"240 ms","url":"/submissions/detail/416856768/","is_pending":"Not Pending","title":"Minimum Height Trees","memory":"22.2 MB","code":"class Solution:\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n        # O(n) time and space -> three dfs\n        adj = [[] for _ in range(n)]\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n\n        self.dist = (0, 0)\n\n        def dfs(node, dist, visited):\n            visited[node] = True\n            if dist > self.dist[0]:\n                self.dist = (dist, node)\n            for child in adj[node]:\n                if not visited[child]:\n                    dfs(child, dist + 1, visited)\n        \n        self.result = []\n        def solve(node, dist, visited, arr):\n            visited[node] = True\n            arr.append(node)\n            if self.result:\n                return\n            if dist == self.dist[0]:\n                print(dist, node, arr)\n                n = len(arr)\n                self.result.append(arr[n // 2])\n                if n % 2 == 0:\n                    self.result.append(arr[n//2 - 1])\n                return\n            \n            for child in adj[node]:\n                if not visited[child]:\n                    solve(child, dist + 1, visited, arr)\n            arr.pop()\n            \n        \n        dfs(0, 1, [False] * n)\n        d1 = self.dist[1]\n        dfs(d1, 1, [False] * n)\n        \n\n        solve(d1, 1, [False] * n, [])\n\n        return self.result\n","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-height-trees"}