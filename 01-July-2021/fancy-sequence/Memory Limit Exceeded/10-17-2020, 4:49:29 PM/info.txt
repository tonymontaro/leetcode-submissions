{"id":409858555,"lang":"java","time":"8 months, 2 weeks","timestamp":1602949769,"status_display":"Memory Limit Exceeded","runtime":"N/A","url":"/submissions/detail/409858555/","is_pending":"Not Pending","title":"Fancy Sequence","memory":"N/A","code":"class Fancy {\n    int idx = 0;\n    int mx = 100001;\n    LazyTree lazy;\n    public Fancy() {\n        lazy = new LazyTree();\n        lazy.build(1, 0, mx);\n    }\n\n    public void append(int val) {\n        int type = 3;\n        lazy.update(1, 0, mx, idx, idx, 3, val);\n        idx++;\n    }\n\n    public void addAll(int inc) {\n        lazy.update(1, 0, mx, 0, idx,  1, inc);\n    }\n\n    public void multAll(int m) {\n        lazy.update(1, 0, mx, 0, idx, 2, m);\n    }\n\n    public int getIndex(int i) {\n        if (i >= idx) return -1;\n        return (int)lazy.query(1, 0, mx, i, i);\n    }\n\n    class LazyTree {\n    int MAXN = 500010;\n    long[] segTree = new long[MAXN];\n    long[] lazyAdd = new long[MAXN];\n    long[] lazyMult = new long[MAXN];\n    long[] realLazy = new long[MAXN];\n    long[] a = new long[MAXN];\n    long mod = 1000000007;\n    void refresh(int node) {\n        lazyAdd[2*node] = (lazyAdd[2*node]*lazyMult[node])%mod;\n        lazyAdd[2*node+1] = (lazyAdd[2*node+1]*lazyMult[node])%mod;\n\n        lazyMult[2*node] = (lazyMult[2*node]*lazyMult[node])%mod;\n        lazyMult[2*node+1] = (lazyMult[2*node+1]*lazyMult[node])%mod;\n\n        lazyAdd[2*node] = (lazyAdd[2*node]+lazyAdd[node])%mod;\n        lazyAdd[2*node+1] = (lazyAdd[2*node+1]+lazyAdd[node])%mod;\n    }\n    void update(int node, int left, int right, int segLeft, int segRight, int type, long value) {\n        if(realLazy[node]>0) {\n            segTree[node] = ((right-left+1)*realLazy[node])%mod;\n            if(left!=right) {\n                realLazy[2*node] = realLazy[2*node+1] = realLazy[node];\n                lazyMult[2*node] = lazyMult[2*node+1] = 1;\n                lazyAdd[2*node] = lazyAdd[2*node+1] = 0;\n            }\n            realLazy[node] = 0;\n        }\n        if(lazyAdd[node]!=0 || lazyMult[node]!=1) {\n            segTree[node] = (segTree[node]*lazyMult[node])%mod;\n            segTree[node] = (segTree[node]+(lazyAdd[node]*(right-left+1))%mod)%mod;\n            if(left!=right)\n                refresh(node);\n            lazyMult[node] = 1;\n            lazyAdd[node] = 0;\n        }\n        if(left>segRight || right<segLeft)\n            return;\n        if(left>=segLeft && right<=segRight) {\n            if(type==1) {\n                segTree[node] = (segTree[node]+((right-left+1)*value)%mod)%mod;\n                if(left!=right) {\n                    lazyAdd[2*node] = (lazyAdd[2*node]+value)%mod;\n                    lazyAdd[2*node+1] = (lazyAdd[2*node+1]+value)%mod;\n                }\n            }\n            else if(type==2) {\n                segTree[node] = (segTree[node]*value)%mod;\n                if(left!=right) {\n                    lazyAdd[2*node] = (lazyAdd[2*node]*value)%mod;\n                    lazyAdd[2*node+1] = (lazyAdd[2*node+1]*value)%mod;\n                    lazyMult[2*node] = (lazyMult[2*node]*value)%mod;\n                    lazyMult[2*node+1] = (lazyMult[2*node+1]*value)%mod;\n                }\n            }\n            else if(type==3) {\n                segTree[node] = (value*(right-left+1))%mod;\n                if(left!=right) {\n                    realLazy[2*node] = realLazy[2*node+1] = value;\n                    lazyAdd[2*node] = lazyAdd[2*node+1] = 0;\n                    lazyMult[2*node] = lazyMult[2*node+1] = 1;\n                }\n            }\n        }\n        else {\n            int mid = (left+right)>>1;\n            update(2*node, left, mid, segLeft, segRight, type, value);\n            update(2*node+1, mid+1, right, segLeft, segRight, type, value);\n            segTree[node] = (segTree[2*node]+segTree[2*node+1])%mod;\n        }\n    }\n    long query(int node, int left, int right, int segLeft, int segRight) {\n        if(realLazy[node]!=0) {\n            segTree[node] = ((right-left+1)*realLazy[node])%mod;\n            if(left!=right) {\n                realLazy[2*node] = realLazy[2*node+1] = realLazy[node];\n                lazyMult[2*node] = lazyMult[2*node+1] = 1;\n                lazyAdd[2*node] = lazyAdd[2*node+1] = 0;\n            }\n            realLazy[node] = 0;\n        }\n        if(lazyAdd[node]!=0 || lazyMult[node]!=1) {\n            segTree[node] = (segTree[node]*lazyMult[node])%mod;\n            segTree[node] = (segTree[node]+(lazyAdd[node]*(right-left+1))%mod)%mod;\n            if(left!=right)\n                refresh(node);\n            lazyMult[node] = 1;\n            lazyAdd[node] = 0;\n        }\n        if(left>segRight || right<segLeft)\n            return 0;\n        if(left>=segLeft && right<=segRight)\n            return segTree[node];\n        else {\n            int mid = (left+right)/2;\n            return (query(2*node, left, mid, segLeft, segRight)+\n                    query(2*node+1, mid+1, right, segLeft, segRight))%mod;\n        }\n    }\n    void build(int node, int left, int right) {\n        if(left==right) {\n            segTree[node] = a[left];\n            lazyMult[node] = 1;\n            lazyAdd[node] = realLazy[node] = 0;\n        }\n        else {\n            int mid = (left+right)/2;\n            build(2*node, left, mid);\n            build(2*node+1, mid+1, right);\n            segTree[node] = (segTree[2*node]+segTree[2*node+1])%mod;\n            realLazy[node] = lazyAdd[node] = 0;\n            lazyMult[node] = 1;\n        }\n    }\n    public void main (String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int q = sc.nextInt();\n        for(int i = 0; i<n; i++)\n            a[i] = sc.nextLong();\n        build(1, 0, n-1);\n        while(q-->0) {\n            int type = sc.nextInt();\n            int l = sc.nextInt()-1;\n            int r = sc.nextInt()-1;\n            if(type!=4) {\n                long value = sc.nextLong();\n                update(1, 0, n-1, l, r, type, value);\n            }\n            else\n                System.out.println(query(1, 0, n-1, l, r));\n        }\n    }\n}\n\n}\n\n/**\n * Your Fancy object will be instantiated and called as such:\n * Fancy obj = new Fancy();\n * obj.append(val);\n * obj.addAll(inc);\n * obj.multAll(m);\n * int param_4 = obj.getIndex(idx);\n */","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"fancy-sequence"}