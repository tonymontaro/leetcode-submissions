{"id":413014128,"lang":"python3","time":"8 months, 1 week","timestamp":1603643507,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/413014128/","is_pending":"Not Pending","title":"Rank Transform of a Matrix","memory":"N/A","code":"class Solution:\n    def matrixRankTransform(self, grid: List[List[int]]) -> List[List[int]]:\n        rowlen = len(grid)\n        colen = len(grid[0])\n        disjoint = UnionFind(rowlen * colen)\n        rows = {i: {} for i in range(rowlen)}\n        cols = {i: {} for i in range(colen)}\n        idx = 0\n        for r in range(rowlen):\n            for c in range(colen):\n                val = grid[r][c]\n                if val in rows[r]:\n                    disjoint.unify(rows[r][val], idx)\n                if val in cols[c]:\n                    disjoint.unify(cols[c][val], idx)\n                rows[r][val] = idx\n                cols[c][val] = idx\n                idx += 1\n        parents = set(disjoint.parents)\n        mapping = {i: [] for i in parents}\n        idx = 0\n        for r in range(rowlen):\n            for c in range(colen):\n                p = disjoint.find(idx)\n                mapping[p].append((grid[r][c], r, c))\n                idx += 1\n        rows = {i: 1 for i in range(rowlen)}\n        cols = {i: 1 for i in range(colen)}\n        parents = sorted(parents, key=lambda x: mapping[x][0][0])\n        for p in parents:\n            rank = 0\n            for (val, row, col) in mapping[p]:\n                rank = max(rank, rows[row], cols[col])\n            for (val, row, col) in mapping[p]:\n                grid[row][col] = rank\n                rows[row] = rank + 1\n                cols[col] = rank + 1\n        return grid\n\n\nclass UnionFind:\n    \"\"\"\n    UnionFind or DisjoinSet data-structure. Zero indexed.\n    Initialize:\n        UnionFind(n)\n    Methods:\n        unify(p, q)        # unify p and q\n        connected(p, q)    # is p connected to q (return bool)\n        find(p)            # find the parent of q\n        getSize(p)         # return the group size of p\n    \"\"\"\n    def __init__(self, n):\n        self.size = n\n        self.groups = n\n        self.sizes = [0] * n\n        self.parents = [0] * n\n        \n        for i in range(n):\n            self.parents[i] = i\n            self.sizes[i] = 1\n    def find(self, p):\n        root = p\n        while (root != self.parents[root]):\n            root = self.parents[root]\n        # path compression\n        while (p != root):\n            p, self.parents[p] = self.parents[p], root\n        return root\n    def getSize(self, p):\n        return self.sizes[self.find(p)]\n    def connected(self, p, q):\n        return self.find(p) == self.find(q)\n    def unify(self, p, q):\n        root1 = self.find(p)\n        root2 = self.find(q)\n        if root1 == root2:\n            return\n        if self.sizes[root1] < self.sizes[root2]:\n            self.parents[root1] = root2\n            self.sizes[root2] += self.sizes[root1]\n        else:\n            self.parents[root2] = root1\n            self.sizes[root1] += self.sizes[root2]\n        self.groups -= 1","compare_result":"11111111111111111111000000000000000000","title_slug":"rank-transform-of-a-matrix"}